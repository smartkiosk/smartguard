#!/usr/bin/env ruby

require "bundler/setup"

require "trollop"
require "eventmachine"
require "json"
require "amqp"

module CommandHandler
  def self.cmd_start
    [ [ "start" ], nil ]
  end

  def self.cmd_stop
    [ [ "stop" ], nil ]
  end

  def self.cmd_restart
    [ [ "restart" ], nil ]
  end

  def self.cmd_status
    done = ->(status) do
      status.each do |service, (pid, active)|
        printf "%-16s: ", service

        if active
          puts "running, pid #{pid}"
        else
          puts "stopped"
        end
      end
    end

    [ [ "status" ], done ]
  end

  def self.cmd_switch_release
    if ARGV.empty?
      warn "release must be specified"
      exit 1
    end

    release = ARGV.shift

    done = ->(success) do
      if success
        puts "releases switched"
      else
        warn "switch failed"
        exit 1
      end
    end

    [ [ "switch_release", release ], done ]
  end
end

opts = Trollop.options do
  version "Smartguard CLI"
  opt :broker, "AMQP broker", default: "amqp://guest:guest@127.0.0.1:5672"
  stop_on_unknown
end

if ARGV.empty?
  warn "command must be specified"
  exit 1
end

cmd = :"cmd_#{ARGV.shift}"

unless CommandHandler.respond_to? cmd
  warn "unsupported command"
  exit 1
end

EventMachine.run do
  amqp_connection = AMQP.connect opts[:broker]
  amqp_channel    = AMQP::Channel.new amqp_connection
  guard_commands  = amqp_channel.fanout "smartguard.commands", auto_delete: true
  guard_status    = amqp_channel.topic "smartguard.events", durable: true

  status_queue    = amqp_channel.queue 'smartguardctl.events', durable: true

  cmd, complete = CommandHandler.send(cmd)

  status_queue.bind guard_status, routing_key: "command.ctl.#", persistent: true

  timer = EventMachine.add_timer(1) do
    warn "Smartguard is not responding"

    exit 1
  end

  status_queue.subscribe do |header, message|
    body = JSON.load(message)

    parts = header.routing_key.split(".")
    if parts[2].to_i == Process.pid
      case parts[3]
      when "started"
        warn "Executing command"
        EventMachine.cancel_timer timer

      when "finished"
        result, error = body
        if !error.nil?
          warn "Command failed: #{error}"
        elsif !complete.nil?
          complete.call result
        end

        exit 0
      end
    end
  end

  guard_commands.publish JSON.dump({
    id: "ctl.#{Process.pid}",
    command: cmd
  })
end
